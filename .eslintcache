[{"/Users/formegusto/Desktop/formegusto/study/study-webrtc-client/src/App.tsx":"1","/Users/formegusto/Desktop/formegusto/study/study-webrtc-client/src/reportWebVitals.ts":"2","/Users/formegusto/Desktop/formegusto/study/study-webrtc-client/src/component/HostComponent.tsx":"3","/Users/formegusto/Desktop/formegusto/study/study-webrtc-client/src/component/AttendantsComponent.tsx":"4","/Users/formegusto/Desktop/formegusto/study/study-webrtc-client/src/index.tsx":"5","/Users/formegusto/Desktop/formegusto/study/study-webrtc-client/src/component/Components/Video/index.tsx":"6","/Users/formegusto/Desktop/formegusto/study/study-webrtc-client/src/lib/PeerConnection.ts":"7"},{"size":439,"mtime":1611068084052,"results":"8","hashOfConfig":"9"},{"size":425,"mtime":1610840844878,"results":"10","hashOfConfig":"9"},{"size":7360,"mtime":1611101230523,"results":"11","hashOfConfig":"9"},{"size":7373,"mtime":1611105373200,"results":"12","hashOfConfig":"9"},{"size":500,"mtime":1610840844877,"results":"13","hashOfConfig":"9"},{"size":920,"mtime":1611099717939,"results":"14","hashOfConfig":"9"},{"size":1086,"mtime":1611098901327,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1tatsw1",{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"20","messages":"21","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"22","messages":"23","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"24"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"27","messages":"28","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"29"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/formegusto/Desktop/formegusto/study/study-webrtc-client/src/App.tsx",[],"/Users/formegusto/Desktop/formegusto/study/study-webrtc-client/src/reportWebVitals.ts",[],"/Users/formegusto/Desktop/formegusto/study/study-webrtc-client/src/component/HostComponent.tsx",["32","33"],"/Users/formegusto/Desktop/formegusto/study/study-webrtc-client/src/component/AttendantsComponent.tsx",["34","35"],"import React, { useState } from 'react';\nimport io from 'socket.io-client';\nimport { useRef } from 'react';\nimport { useEffect } from 'react';\nimport Video from './Components/Video';\nimport { RouteComponentProps } from 'react-router-dom';\n\nconst AttendantComponent = ({ match } : RouteComponentProps) => {\n\n  const [socket, setSocket] = useState<SocketIOClient.Socket>();\n  const [users, setUsers] = useState<Array<IWebRTCUser>>([]);\n\n  let localVideoRef = useRef<HTMLVideoElement>(null);\n\n  let sendPC: RTCPeerConnection;\n  let receivePCs: any;\n  \n  const pc_config = {\n    \"iceServers\": [\n      // {\n      //   urls: 'stun:[STUN_IP]:[PORT]',\n      //   'credentials': '[YOR CREDENTIALS]',\n      //   'username': '[USERNAME]'\n      // },\n      {\n        urls : 'stun:stun.l.google.com:19302'\n      }\n    ]\n  }\n\n  useEffect(() => {\n    let newSocket = io.connect('http://localhost:8080');\n    let localStream: MediaStream;\n    \n    newSocket.on('allUsers', (data: {users: Array<{id: string}>}) => {\n      let len = data.users.length;\n      for (let i = 0; i < len; i++) {\n        console.log(data.users[i]);\n\n        createReceivePC(data.users[i].id, newSocket);\n      }\n    });\n\n    newSocket.on('userExit', (data: {id: string}) => {\n      if(receivePCs[data.id]) {\n        receivePCs[data.id].close();\n        delete receivePCs[data.id];\n        setUsers(users => users.filter(user => user.id !== data.id));\n      }\n    });\n\n    newSocket.on('getSenderAnswer', async (data: {sdp: RTCSessionDescription}) => {\n      try {\n        console.log('get sender answer');\n        await sendPC.setRemoteDescription(new RTCSessionDescription(data.sdp));\n      } catch (error) {\n        console.log(error);\n      }\n    });\n\n    newSocket.on('getSenderCandidate', async(data: {candidate: RTCIceCandidateInit}) => {\n      try {\n        console.log('get sender candidate');\n        if (!data.candidate) return;\n        sendPC.addIceCandidate(new RTCIceCandidate(data.candidate));\n        console.log('candidate add success');\n      } catch (error) {\n        console.log(error);\n      }\n    });\n\n    newSocket.on('getReceiverAnswer', async(data: {id: string, sdp: RTCSessionDescription}) => {\n      try {\n        console.log(`get socketID(${data.id})'s answer`);\n        let pc: RTCPeerConnection = receivePCs[data.id];\n        await pc.setRemoteDescription(data.sdp);\n        console.log(`socketID(${data.id})'s set remote sdp success`);\n      } catch (error) {\n        console.log(error);\n      }\n    });\n\n    newSocket.on('getReceiverCandidate', async(data: {id: string, candidate: RTCIceCandidateInit}) => {\n      try {\n        console.log(`get socketID(${data.id})'s candidate`);\n        let pc: RTCPeerConnection = receivePCs[data.id];\n        if (!data.candidate) return;\n        pc.addIceCandidate(new RTCIceCandidate(data.candidate));\n        console.log(`socketID(${data.id})'s candidate add success`);\n      } catch (error) {\n        console.log(error);\n      }\n    });\n\n    setSocket(newSocket);\n\n    navigator.mediaDevices.getUserMedia({\n      audio: true,\n      video: {\n        width: 240,\n        height: 240\n      }\n    }).then(stream => {\n      if (localVideoRef.current) localVideoRef.current.srcObject = stream;\n\n      localStream = stream;\n\n      sendPC = createSenderPeerConnection(newSocket, localStream);\n      createSenderOffer(newSocket);\n      \n      const { room } = match.params as any;\n      newSocket.emit('joinRoom', {\n        id: newSocket.id,\n        roomID: room,\n        role: \"ATTENDANT\"\n      });\n    }).catch(error => {\n      console.log(`getUserMedia error: ${error}`);\n    });\n  }, []);\n\n  const createReceivePC = (id: string, newSocket: SocketIOClient.Socket) => {\n    try {\n      console.log(`socketID(${id}) user entered`);\n      let pc = createReceiverPeerConnection(id, newSocket);\n      createReceiverOffer(pc, newSocket, id);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  const createSenderOffer = async(newSocket: SocketIOClient.Socket) => {\n    try {\n      let sdp = await sendPC.createOffer({offerToReceiveAudio: false, offerToReceiveVideo: false});\n      console.log('create sender offer success');\n      await sendPC.setLocalDescription(new RTCSessionDescription(sdp));\n\n      const { room } = match.params as any;\n      newSocket.emit('senderOffer', {\n        sdp,\n        senderSocketID: newSocket.id,\n        roomID: room,\n        role: 'ATTENDANT'\n      });\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  const createReceiverOffer = async(pc: RTCPeerConnection, newSocket: SocketIOClient.Socket, senderSocketID: string) => {\n    try {\n      let sdp = await pc.createOffer({offerToReceiveAudio: true, offerToReceiveVideo: true});\n      console.log('create receiver offer success');\n      await pc.setLocalDescription(new RTCSessionDescription(sdp));\n\n      const { room } = match.params as any;\n      newSocket.emit('receiverOffer', {\n        sdp,\n        receiverSocketID: newSocket.id,\n        senderSocketID,\n        roomID: room\n      });\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  const createSenderPeerConnection = (newSocket: SocketIOClient.Socket, localStream: MediaStream): RTCPeerConnection => {\n\n    let pc = new RTCPeerConnection(pc_config);\n\n    pc.onicecandidate = (e) => {\n      if (e.candidate) {\n        console.log('sender PC onicecandidate');\n        newSocket.emit('senderCandidate', {\n          candidate: e.candidate,\n          senderSocketID: newSocket.id\n        });\n      }\n    }\n\n    pc.oniceconnectionstatechange = (e) => {\n      console.log(e);\n    }\n\n    if (localStream){\n      console.log('localstream add');\n      localStream.getTracks().forEach(track => {\n        pc.addTrack(track, localStream);\n      });\n    } else {\n      console.log('no local stream');\n    }\n\n    // return pc\n    return pc;\n  }\n\n  const createReceiverPeerConnection = (socketID: string, newSocket: SocketIOClient.Socket): RTCPeerConnection => {\n    let pc = new RTCPeerConnection(pc_config);\n\n    // add pc to peerConnections object\n    receivePCs = {...receivePCs, [socketID]: pc};\n\n    pc.onicecandidate = (e) => {\n      if (e.candidate) {\n        console.log('receiver PC onicecandidate');\n        newSocket.emit('receiverCandidate', {\n          candidate: e.candidate,\n          receiverSocketID: newSocket.id,\n          senderSocketID: socketID\n        });\n      }\n    }\n\n    pc.oniceconnectionstatechange = (e) => {\n      console.log(e);\n    }\n    \n    pc.ontrack = (e) => {\n      console.log('ontrack success');\n      setUsers(oldUsers => oldUsers.filter(user => user.id !== socketID));\n      setUsers(oldUsers => [...oldUsers, {\n        id: socketID,\n        stream: e.streams[0]\n      }]);\n    }\n\n    // return pc\n    return pc;\n  }\n\n  return (\n    <div>\n        <h1>참석자는 이부분이 필요없음</h1>\n        {/* <video\n          style={{\n            width: 240,\n            height: 240,\n            margin: 5,\n            backgroundColor: 'black'\n          }}\n          muted\n          ref={ localVideoRef }\n          autoPlay>\n        </video> */}\n        <h1>{`누군가의 ${(match.params as any).room}번 웨비나`}</h1>\n        {users.map((user, index) => {\n          return(\n            <Video\n              key={index}\n              stream={user.stream}\n            />\n          );\n        })}\n      </div>\n  );\n}\n\nexport default AttendantComponent;\n","/Users/formegusto/Desktop/formegusto/study/study-webrtc-client/src/index.tsx",[],"/Users/formegusto/Desktop/formegusto/study/study-webrtc-client/src/component/Components/Video/index.tsx",["36"],"import React, { useEffect, useRef, useState } from 'react';\nimport Styled from 'styled-components';\n\nconst Container = Styled.div`\n    position: relative;\n    display: inline-block;\n    width: 240px;\n    height: 240px;\n    margin: 5px;\n`;\n\nconst VideoContainer = Styled.video`\n    width: 240px;\n    height: 240px;\n    background-color: black;\n`;\n\ninterface Props {\n    stream: MediaStream;\n    muted?: boolean;\n}\n\nconst Video = ({stream, muted}: Props) => {\n    const ref = useRef<HTMLVideoElement>(null);\n    const [isMuted, setIsMuted] = useState<boolean>(false);\n\n    useEffect(() => {\n        if (ref.current) ref.current.srcObject = stream;\n        if (muted) setIsMuted(muted);\n    })\n\n    return (\n        <Container>\n            <VideoContainer \n                ref={ref}\n                muted={isMuted}\n                autoPlay\n            ></VideoContainer>\n        </Container>\n    );\n}\n\nexport default Video;","/Users/formegusto/Desktop/formegusto/study/study-webrtc-client/src/lib/PeerConnection.ts",[],{"ruleId":"37","severity":1,"message":"38","line":10,"column":10,"nodeType":"39","messageId":"40","endLine":10,"endColumn":16},{"ruleId":"41","severity":1,"message":"42","line":108,"column":16,"nodeType":"43","endLine":108,"endColumn":66},{"ruleId":"37","severity":1,"message":"38","line":10,"column":10,"nodeType":"39","messageId":"40","endLine":10,"endColumn":16},{"ruleId":"41","severity":1,"message":"42","line":112,"column":16,"nodeType":"43","endLine":112,"endColumn":66},{"ruleId":"41","severity":1,"message":"44","line":27,"column":5,"nodeType":"39","endLine":27,"endColumn":14,"suggestions":"45"},"@typescript-eslint/no-unused-vars","'socket' is assigned a value but never used.","Identifier","unusedVar","react-hooks/exhaustive-deps","Assignments to the 'sendPC' variable from inside React Hook useEffect will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside useEffect.","CallExpression","React Hook useEffect contains a call to 'setIsMuted'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass [stream, muted] as a second argument to the useEffect Hook.",["46"],{"desc":"47","fix":"48"},"Add dependencies array: [stream, muted]",{"range":"49","text":"50"},[689,689],", [stream, muted]"]